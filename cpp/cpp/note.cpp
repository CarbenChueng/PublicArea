//
//  test1.cpp
//  Num_1
//
//  Created by kabun  on 2020/4/18.
//  Copyright © 2020 kabun . All rights reserved.
//

//#pragma once防止头文件重复包含

/*
 ====================================================常量=======================================================
 常量： 不能被修改
 #define Day 7 (通常在文件上方定义)
 const int month = 12;
 
 cout << ::a 访问全局变量的值
 
 ====================================================数据类型=======================================================
 short（短整）          2字节           -2^15--2^15-1   (-32768-32767)
 int（整）              4              -2^31--2^31-1
 long(win 4,linux 32-4,64-8)          -2^31--2^31-1
 long long             8              -2^63--2^63-1
 float(浮点)            4              7位有效数字         默认情况下输出6位数字
 double(浮点)           8              15-16位有效数字     默认情况下输出6位数字
 char(字符，必须单引号)   1
 string(字符串，要加头文件)。             例子：string haha = "*******";
 
 除了0都为真
 true                  1              返回1
 flase                 1              返回0
 //科学计数法
 float f2 = 3e2;//3*10^2
 float f3 = 3e-2;//3*10^-2
 
 cin >>   获取数据类型
 
  ====================================================运算符=======================================================
 a++    运算后加一
 ++a    运算前加一
 %      取余数。     10 % 3 = 1  (两个小数不能取模运算，且两数不能为0)
 /      除法：直接抹掉小数，只保留整数
 ！      非
 &&     与
 ｜｜     或

 三目运算： 三目运算符运算后还可以赋值
 a > b ? a:b;（a是否比b大，如果是就返回a，否则返回b）
 （a > b ? a:b）= 100；
 
  ====================================================判断=======================================================
 switch
 缺点：只能判断整形和字符型，不能非与或，不能判断区间
 优点：结构清晰，效率高
 ----------------随机-------------
 //添加随机数种子  利用当前系统时间生成随机数，防止每次随机数都一样
#include <ctime> 要加头文件
srand((unsigned int)time(NULL));
 
rand()% 100  生成0-99的随机数
 ------------goto-------------
 goto haha; 注意标点符号的不同
 haha:      注意标点符号的不同
 
 ====================================================数组=======================================================
创建方法：
 1:数据类型 数组名【长度】；                        int arr[6];
 2:数据类型 数组名【长度】 = {数值1 ，2，3，4，}；    int arr[6] = {1,2,3,4,5,6};
 3:数据类型 数组名【长度】；                        int arr[] = {1,2,3};
 
 二维数组：
 1:数据类型 数组名【行】【列】；                        int arr[6][5];
 2:数据类型 数组名【行】【列】 = {{1 ，2}，{3，4}}；     int arr[2][2] = {{1,2,3},{4,5,6}};
 3:数据类型 数组名【行】【列】 = {1,2,3,4}；
 4:数据类型 数组名【】【列】 = {1,2,3,4}；
 
  ====================================================函数=======================================================
 1:有返回值用：int，无返回值用：void
 2:值传递，形参不会影响实参
 3:函数声明：int haha(num); 如果函数定义在main的后面，可以在前面声明一下该函数，就可以用了
 
 函数的份文件编写： 不清楚就看第五十五的教程
 1:创建头文件（。h）和源文件（。cpp），必须同名
 2:在头文件中写函数的声明
 3:在原文件中写函数的定义
 
  ====================================================指针=======================================================
 32位系统      4字节
 64位系统      8字节
 
 const int* p =&a   常量指针，可以修改方向不能修改值
 p = 20;            错误
 p = &b;            正确
 
 int* const p =&a   指针常量，可以修改值不能修改方向
 p = 20;            正确
 p = &b;            错误
 
 const int* const p = &a 啥都不能修改
 
 ====================================================结构体=======================================================
函数中如果用结构体指针，省内存空间，但是容易误操作修改值，所以最好加上const
 
 
 
 
 ====================================================内存分区模型=======================================================
代码区：存放函数体的二进制代码，由系统进行管理
        存放cpu执行的机器指令
        共享：被频繁执行，只需要一份
        只读：防止意外被修改
 
全局区：存放全局变量，静态变量，常量，字符串    static int i = 10;这就是静态变量
        该区域的数据在程序结束后由系统释放
        这些都会存放在同一个区域
 
栈区：存放局部变量，函数参数等，由编译器自动分配释放
        局部常量和变量都放在一个区域
        不要返回局部变量的地址
        先进后出
 
 
堆区：由程序员分配和释放，程序结束时由系统回收
        开辟堆区用new，而且返回的是指针
        释放用delete,如果你要释放数组要加[]    delete[]

====================================================引用=======================================================
 1:必须初始化。        int &b;这是错误的
 2:初始化后不可以改变    int &b =a;    int &b =;/这是错误的
 3:不要返回局部变量的引用，全局 静态，常量等都可以
 4:函数调用可以作为左值
 5:引用的本质就是一个指针常量 int& a = b; (int* const a = &b)
 6:引用必须引合法的内存空间。 int& a = 10;这是不可以的。除非是const int& a = 10;

 
 ====================================================函数传值=======================================================
 1:如果某个位置已经有了默认参数，那么从这个位置往后，从左到右必须有默认值
 2:声明和实现只能有一个有默认参数，不然就会产生二意性
 3:站位参数,可以不给名字，只给数据类型，如果有值，那么调用的时候可以只传一个就可以了。
 
 函数重载作用：  函数名相同 提高复用性
 函数重载注意点：
 1:同一个作用域下
 2:函数名相同
 3:函数参数的，类型，顺序(前提要类型不同)，个数其中一个不同
 4:函数的返回值不可以作为函数重载的条件(int func(),void func())这样是不行的
 
====================================================类和对象=======================================================
 类中的属性和行为我们都统称成员
 属性：成员属性 成员变量
 行为：成员行为 成员方法
 
 访问权限：
 公共：public              成员类内，类外都可以访问
 保护：protected           成员类内可以访问，类外不可以访问，子类可以访问
 私有：private             成员类内可以访问，类外不可以访问，子类不可以访问
 
 struct和class的区别在于：struct默认权限为公有，类外可以访问，class相反
 
 成员属性设置为私有的优点
 1:可以自己控制读写权限
 2:对于写的权限，可以检测数据的有效性
 
 //================================================构造函数的基本了解===================================================
 //对象初始化和清理
 构造函数：创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动
 格式：类名(){}
 析构函数：对象销毁前系统自动调用，执行一些清理工作
 格式：~类名(){}
 两者的特点：
 1：都没有返回值，也不用写void
 2：函数名称与类名相同（析构要加～）
 3：构造有参数，可以发生重载，析构则相反。
 4：构造：程序在调用对象时候会自动调用构造，析构：程序在对象销毁前会自动调用析构。两者都只会调用一次。
 
 //================================================构造函数的调用和分类===================================================
 两种分类方式：
 按参数分为：有参和无参构造
 按类型分为：普通构造和拷贝构造
 
 三种调用方式：
 括号法，显示法，隐藏转换法
 //括号法。推荐括号法
 //Person p1;//默认构造
 //Person p2(10);//有参构造
 //Person p3(p2);//拷贝构造
 //cout << p2.age << endl;
 //cout << p3.age << endl;
 //(注意：调用默认构造时候不要加(),因为这样编译器会认为是一个函数的声明)
 
 //显示法
 //Person p1;
 //Person p2 = Person(10);//有参
 //Person p3 = Person(p2);//拷贝
 //Person(10) 为匿名构造函数，执行后会被释放
 //cout << "aaaaa" <<endl;
 //(注意：不要利用拷贝函数初始化匿名对象,下面会被编译器认为 Person p3;跟上面的一样了)
 //Person(p3);
 
 //隐式转换法
 Person p4 = 10; //相当于Person(10);
 Person p5 = p4;//拷贝构造
 
 拷贝构造函数的调用时机
 1:使用一个已经创建完毕的对象来初始化一个新对象
 2:值传递的方式给函数参数传值
 3；以值的方式返回局部对象
 
 //构造函数的调用规则
 //默认情况下，c++编译器至少给一个类添加3个函数
 //1:默认构造（无参，函数体为空）
 //2:默认析构（无参，函数体为空）
 //3:默认拷贝构造，对属性进行值拷贝

 //调用规则
 //1:如果用户定义有参构造函数。c++不再提供默认无参构造，但是会提供默认拷贝构造
 //2:如果用户定义拷贝构造函数，c++不再提供其他构造函数
 
 //================================================深拷贝和浅拷贝==================================================
 
 浅拷贝带来的问题就是堆区内存重复释放（特别注意栈区，因为展区先进后出）
 解决：深拷贝
 
 //================================================this==================================================
 this指针的用途
 1:当形参和成员变量同名时，可用this指针区分
 2:在类的非静态成员函数中返回对象本身，可用return* this
 
 
 //============================================const函数==========================================
 常函数：
 1:不能修改成员属性
 2:成员属性声明时加mutable就可以修改了
 
 常对象：
 常对象只能调用常函数
 
 //============================================友元==========================================
 友元的三种实现：
 1:全局函数做友元
 2:类做友元
 3:成员函数做友元
 
 //===========================================加号运算符重载=========================================
 1:对于内置的数据类型的表达式的运算符是不可能改变的
 2:不要滥用运算符重载（加法就实现加法，不要里面变减法）
 
 //===========================================左移运算符重载==========================================
 //只能用全局函数重载左移运算符
 friend ostream& operator<<(ostream& cout,Person& p);
 
 
 
 
 ====================================================继承=======================================================
 1:减少重复代码
 2:class 子类 : 继承方式（public/private/....） 父类
 3:继承权限取决于上一层的继承类型
 4:父类中所有静态的成员属性都会被子类继承下去，其中私有成员是被编译器隐藏了
 
 利用vs开发人员命令提示工具查看对象类型
 跳转到你要查看的对象的cpp的路径
 查看命名
 cl/d1 reportSingleClassLayout类名 cpp文件名（可以tab补全）

 继承中的构造和析构的顺序：
 先构造父类，然后子类，析构相反
 
 ===============继承中，同名成员的处理方式
 1:继承中 会优先访问子类的同名变量和函数
 2:加作用域可以访问父类中的同名变量和函数
 3:如果父类中出现和子类同名的成员函数，子类的同名成员会隐藏掉父类所有的同名成员，如果想访问需要加作用域
 
 */
